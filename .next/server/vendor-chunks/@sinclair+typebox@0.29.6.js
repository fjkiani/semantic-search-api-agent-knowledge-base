"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sinclair+typebox@0.29.6";
exports.ids = ["vendor-chunks/@sinclair+typebox@0.29.6"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@sinclair+typebox@0.29.6/node_modules/@sinclair/typebox/typebox.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sinclair+typebox@0.29.6/node_modules/@sinclair/typebox/typebox.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for('TypeBox.Modifier');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema) {\n        super('TypeGuard: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n    }\n    function IsArray(value) {\n        return typeof value === 'object' && value !== null && Array.isArray(value);\n    }\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (typeof value !== 'string')\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    function IsNumber(value) {\n        return typeof value === 'number' && globalThis.Number.isFinite(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    function IsOptionalBigInt(value) {\n        return value === undefined || (value !== undefined && IsBigInt(value));\n    }\n    function IsOptionalNumber(value) {\n        return value === undefined || (value !== undefined && IsNumber(value));\n    }\n    function IsOptionalBoolean(value) {\n        return value === undefined || (value !== undefined && IsBoolean(value));\n    }\n    function IsOptionalString(value) {\n        return value === undefined || (value !== undefined && IsString(value));\n    }\n    function IsOptionalPattern(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return value === undefined || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */\n    function TAny(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Any' && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */\n    function TArray(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Array' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'BigInt' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'BigInt' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.multipleOf) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.exclusiveMaximum));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Boolean' &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Constructor' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Constructor' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */\n    function TDate(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Date' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Function' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Function' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */\n    function TInteger(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Integer' &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Intersect' &&\n            IsArray(schema.allOf) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if ('type' in schema && schema.type !== 'object') {\n            return false;\n        }\n        for (const inner of schema.allOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TKind */\n    function TKind(schema) {\n        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral<string> */\n    function TLiteralString(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'string';\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given schema is TLiteral<number> */\n    function TLiteralNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'number';\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given schema is TLiteral<boolean> */\n    function TLiteralBoolean(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'boolean';\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given schema is TLiteral */\n    function TLiteral(schema) {\n        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */\n    function TNever(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Never' && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Not' &&\n            TSchema(schema.not));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Null' &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */\n    function TNumber(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Number' &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */\n    function TObject(schema) {\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Object' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsObject(schema.properties) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)) {\n            if (!IsControlCharacterFree(key))\n                return false;\n            if (!TSchema(value))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Promise' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Record' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.keys(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Ref' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */\n    function TString(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'String' &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Symbol' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'TemplateLiteral' &&\n            schema.type === 'string' &&\n            IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'This' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Tuple' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            IsNumber(schema.minItems) &&\n            IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n            return true;\n        }\n        if (!IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Undefined' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Union' &&\n            IsArray(schema.anyOf) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUint8Array */\n    function TUint8Array(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Uint8Array' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.instanceOf === 'Uint8Array' && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unknown' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */\n    function TUnsafe(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Void' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the ReadonlyOptional modifier */\n    function TReadonlyOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'ReadonlyOptional';\n    }\n    TypeGuard.TReadonlyOptional = TReadonlyOptional;\n    /** Returns true if this schema has the Readonly modifier */\n    function TReadonly(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */\n    function TOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */\n    function TSchema(schema) {\n        return (typeof schema === 'object' &&\n            (TAny(schema) ||\n                TArray(schema) ||\n                TBoolean(schema) ||\n                TBigInt(schema) ||\n                TConstructor(schema) ||\n                TDate(schema) ||\n                TFunction(schema) ||\n                TInteger(schema) ||\n                TIntersect(schema) ||\n                TLiteral(schema) ||\n                TNever(schema) ||\n                TNot(schema) ||\n                TNull(schema) ||\n                TNumber(schema) ||\n                TObject(schema) ||\n                TPromise(schema) ||\n                TRecord(schema) ||\n                TRef(schema) ||\n                TString(schema) ||\n                TSymbol(schema) ||\n                TTemplateLiteral(schema) ||\n                TThis(schema) ||\n                TTuple(schema) ||\n                TUndefined(schema) ||\n                TUnion(schema) ||\n                TUint8Array(schema) ||\n                TUnknown(schema) ||\n                TUnsafe(schema) ||\n                TVoid(schema) ||\n                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === 'Undefined')\n            return true;\n        if (schema[exports.Kind] === 'Not') {\n            return !Check(schema.not);\n        }\n        if (schema[exports.Kind] === 'Intersect') {\n            const intersect = schema;\n            return intersect.allOf.every((schema) => Check(schema));\n        }\n        if (schema[exports.Kind] === 'Union') {\n            const union = schema;\n            return union.anyOf.some((schema) => Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function AnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Any(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function ArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function BigInt(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function BooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'boolean')\n            return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Boolean(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function Constructor(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function Date(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function Function(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TFunction(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function IntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'number')\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Integer(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function IntersectRight(left, right) {\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Intersect(left, right) {\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function IsLiteralString(schema) {\n        return typeof schema.const === 'string';\n    }\n    function IsLiteralNumber(schema) {\n        return typeof schema.const === 'number';\n    }\n    function IsLiteralBoolean(schema) {\n        return typeof schema.const === 'boolean';\n    }\n    function Literal(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function NeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function Never(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapNot(schema) {\n        let [current, depth] = [schema, 0];\n        while (true) {\n            if (!TypeGuard.TNot(current))\n                break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function Not(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        if (TypeGuard.TNot(left))\n            return Visit(UnwrapNot(left), right);\n        if (TypeGuard.TNot(right))\n            return Visit(left, UnwrapNot(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for Not`);\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function Null(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function NumberRight(left, right) {\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Number(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return globalThis.Object.keys(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False)\n            return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))\n            return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function ObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Object(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (!TypeGuard.TObject(right))\n            return TypeExtendsResult.False;\n        for (const key of globalThis.Object.keys(right.properties)) {\n            if (!(key in left.properties))\n                return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function Promise(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties)\n            return exports.Type.String();\n        throw Error('TypeExtends: Cannot get record key');\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternStringExact];\n        throw Error('TypeExtends: Cannot get record value');\n    }\n    function RecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of globalThis.Object.keys(left.properties)) {\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Record(left, right) {\n        const Value = RecordValue(left);\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TRecord(right))\n            return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function StringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'string')\n            return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function String(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function Symbol(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        if (TypeGuard.TTemplateLiteral(left))\n            return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right))\n            return Visit(left, TemplateLiteralResolver.Resolve(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function TupleRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function IsArrayOfTuple(left, right) {\n        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);\n    }\n    function Tuple(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right))\n            return TypeExtendsResult.False;\n        if ((left.items === undefined && right.items !== undefined) || (left.items !== undefined && right.items === undefined))\n            return TypeExtendsResult.False;\n        if (left.items === undefined && right.items === undefined)\n            return TypeExtendsResult.True;\n        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function Uint8Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function Undefined(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TVoid(right))\n            return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function UnionRight(left, right) {\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Union(left, right) {\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function UnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Unknown(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        if (TypeGuard.TArray(right))\n            return ArrayRight(left, right);\n        if (TypeGuard.TTuple(right))\n            return TupleRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Void(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // Resolvable Types\n        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))\n            return TemplateLiteral(left, right);\n        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))\n            return Not(left, right);\n        // Standard Types\n        if (TypeGuard.TAny(left))\n            return Any(left, right);\n        if (TypeGuard.TArray(left))\n            return Array(left, right);\n        if (TypeGuard.TBigInt(left))\n            return BigInt(left, right);\n        if (TypeGuard.TBoolean(left))\n            return Boolean(left, right);\n        if (TypeGuard.TConstructor(left))\n            return Constructor(left, right);\n        if (TypeGuard.TDate(left))\n            return Date(left, right);\n        if (TypeGuard.TFunction(left))\n            return Function(left, right);\n        if (TypeGuard.TInteger(left))\n            return Integer(left, right);\n        if (TypeGuard.TIntersect(left))\n            return Intersect(left, right);\n        if (TypeGuard.TLiteral(left))\n            return Literal(left, right);\n        if (TypeGuard.TNever(left))\n            return Never(left, right);\n        if (TypeGuard.TNull(left))\n            return Null(left, right);\n        if (TypeGuard.TNumber(left))\n            return Number(left, right);\n        if (TypeGuard.TObject(left))\n            return Object(left, right);\n        if (TypeGuard.TRecord(left))\n            return Record(left, right);\n        if (TypeGuard.TString(left))\n            return String(left, right);\n        if (TypeGuard.TSymbol(left))\n            return Symbol(left, right);\n        if (TypeGuard.TTuple(left))\n            return Tuple(left, right);\n        if (TypeGuard.TPromise(left))\n            return Promise(left, right);\n        if (TypeGuard.TUint8Array(left))\n            return Uint8Array(left, right);\n        if (TypeGuard.TUndefined(left))\n            return Undefined(left, right);\n        if (TypeGuard.TUnion(left))\n            return Union(left, right);\n        if (TypeGuard.TUnknown(left))\n            return Unknown(left, right);\n        if (TypeGuard.TVoid(left))\n            return Void(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function Array(value) {\n        return value.map((value) => Visit(value));\n    }\n    function Object(value) {\n        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function Visit(value) {\n        if (IsArray(value))\n            return Array(value);\n        if (IsObject(value))\n            return Object(value);\n        return value;\n    }\n    /** Clones a type. */\n    function Clone(schema, options) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema) => {\n            const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema, {});\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema) => TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema) => TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        const optional = IsIntersectOptional(schema.allOf);\n        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        const optional = IsUnionOptional(schema.anyOf);\n        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        if (schema[exports.Kind] === 'Intersect')\n            return ResolveIntersect(schema);\n        if (schema[exports.Kind] === 'Union')\n            return ResolveUnion(schema);\n        return schema;\n    }\n    function Intersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema) => {\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function Union(schema, key) {\n        const resolved = schema.anyOf.map((schema) => Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function Object(schema, key) {\n        const property = schema.properties[key];\n        return property === undefined ? exports.Type.Never() : exports.Type.Union([property]);\n    }\n    function Tuple(schema, key) {\n        const items = schema.items;\n        if (items === undefined)\n            return exports.Type.Never();\n        const element = items[key]; //\n        if (element === undefined)\n            return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        if (schema[exports.Kind] === 'Intersect')\n            return Intersect(schema, key);\n        if (schema[exports.Kind] === 'Union')\n            return Union(schema, key);\n        if (schema[exports.Kind] === 'Object')\n            return Object(schema, key);\n        if (schema[exports.Kind] === 'Tuple')\n            return Tuple(schema, key);\n        return exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key) => Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function Intersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Union(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Object(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === 'Intersect')\n            return Intersect(schema, callback);\n        if (schema[exports.Kind] === 'Union')\n            return Union(schema, callback);\n        if (schema[exports.Kind] === 'Object')\n            return Object(schema, callback);\n        return schema;\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n    }\n    function Intersect(schema, options) {\n        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n    }\n    function Union(schema, options) {\n        const sets = schema.anyOf.map((inner) => Visit(inner, options));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function Object(schema, options) {\n        return globalThis.Object.keys(schema.properties);\n    }\n    function Record(schema, options) {\n        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        if (TypeGuard.TIntersect(schema))\n            return Intersect(schema, options);\n        if (TypeGuard.TUnion(schema))\n            return Union(schema, options);\n        if (TypeGuard.TObject(schema))\n            return Object(schema, options);\n        if (TypeGuard.TRecord(schema))\n            return Record(schema, options);\n        return [];\n    }\n    /** Resolves an array of keys in this schema */\n    function ResolveKeys(schema, options) {\n        return [...new Set(Visit(schema, options))];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */\n    function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, { includePatterns: true });\n        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);\n        return `^(${pattern.join('|')})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */\n    function Resolve(schema) {\n        if (globalThis.Array.isArray(schema))\n            return schema;\n        if (TypeGuard.TUnionLiteral(schema))\n            return schema.anyOf.map((schema) => schema.const.toString());\n        if (TypeGuard.TLiteral(schema))\n            return [schema.const];\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n            if (!TemplateLiteralFinite.Check(expression))\n                throw Error('KeyArrayResolver: Cannot resolve keys from infinite template expression');\n            return [...TemplateLiteralGenerator.Generate(expression)];\n        }\n        return [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n    function* Union(union) {\n        for (const schema of union.anyOf) {\n            if (schema[exports.Kind] === 'Union') {\n                yield* Union(schema);\n            }\n            else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */\n    function Resolve(union) {\n        return exports.Type.Union([...Union(union)], { ...union });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n            return pattern;\n        }\n        else if (TypeGuard.TUnion(schema)) {\n            const tokens = schema.anyOf.map((schema) => Visit(schema, acc)).join('|');\n            return `(${tokens})`;\n        }\n        else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        }\n        else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        }\n        else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        }\n        else if (TypeGuard.TNever(schema)) {\n            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');\n        }\n        else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        if (IsGroup(pattern))\n            return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern))\n            return Or(pattern);\n        if (IsPrecedenceAnd(pattern))\n            return And(pattern);\n        return { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        if (IsBoolean(expression))\n            return true;\n        if (IsNumber(expression) || IsString(expression))\n            return false;\n        if (expression.type === 'and')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'or')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'const')\n            return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === 'and')\n            return yield* And(expression);\n        if (expression.type === 'or')\n            return yield* Or(expression);\n        if (expression.type === 'const')\n            return yield* Const(expression);\n        throw Error('TemplateLiteralGenerator: Unknown expression');\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, '');\n        if (trim === 'boolean')\n            return yield exports.Type.Boolean();\n        if (trim === 'number')\n            return yield exports.Type.Number();\n        if (trim === 'bigint')\n            return yield exports.Type.BigInt();\n        if (trim === 'string')\n            return yield exports.Type.String();\n        const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));\n        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== '{') {\n            const L = exports.Type.Literal('$');\n            const R = ParseLiteral(template.slice(1));\n            return yield* [L, ...R];\n        }\n        for (let i = 2; i < template.length; i++) {\n            if (template[i] === '}') {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [...L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for (let i = 0; i < template.length; i++) {\n            if (template[i] === '$') {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [...ParseLiteral(template_dsl)];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Modifier]` Creates a Optional property */\n    Optional(schema) {\n        return { [exports.Modifier]: 'Optional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a ReadonlyOptional property */\n    ReadonlyOptional(schema) {\n        return { [exports.Modifier]: 'ReadonlyOptional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a Readonly object or property */\n    Readonly(schema) {\n        return { [exports.Modifier]: 'Readonly', ...schema };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Standard]` Creates an Array type */\n    Array(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(items, {}) });\n    }\n    /** `[Standard]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Standard]` Creates a Composite object type. */\n    Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });\n        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Standard]` Creates a Enum type */\n    Enum(item, options = {}) {\n        // prettier-ignore\n        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const anyOf = values.map((value) => (typeof value === 'string' ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));\n        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });\n    }\n    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */\n    Exclude(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options));\n        }\n    }\n    /** `[Standard]` Extracts from the left type any type that is assignable to the right */\n    Extract(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options));\n        }\n    }\n    /** `[Standard]` Returns indexed property types for the given keys */\n    Index(schema, unresolved, options = {}) {\n        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {\n            return TypeClone.Clone(schema.items, options);\n        }\n        else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const cloned = items.map((schema) => TypeClone.Clone(schema, {}));\n            return this.Union(cloned, options);\n        }\n        else {\n            const keys = KeyArrayResolver.Resolve(unresolved);\n            const clone = TypeClone.Clone(schema, {});\n            return IndexedAccessor.Resolve(clone, keys, options);\n        }\n    }\n    /** `[Standard]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });\n        }\n        else {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact)\n                return this.Number(options);\n            if (pattern === exports.PatternStringExact)\n                return this.String(options);\n            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');\n        }\n        else if (TypeGuard.TTuple(schema)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const literals = items.map((_, index) => exports.Type.Literal(index));\n            return this.Union(literals, options);\n        }\n        else if (TypeGuard.TArray(schema)) {\n            return this.Number(options);\n        }\n        else {\n            const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });\n            if (keys.length === 0)\n                return this.Never(options);\n            const literals = keys.map((key) => this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Standard]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Standard]` Creates a Not type */\n    Not(not, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', not });\n    }\n    /** `[Standard]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Standard]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Standard]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });\n        }\n        else {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n        }\n    }\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => !keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Optional */\n    Partial(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Optional':\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n                default:\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            delete schema.required;\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (!keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else if (TypeGuard.TUnion(key)) {\n            const union = UnionResolver.Resolve(key);\n            if (TypeGuard.TUnionLiteral(union)) {\n                const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});\n                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n            }\n            else\n                throw Error('TypeBuilder: Record key of type union contains non-literal types');\n        }\n        else if (TypeGuard.TLiteral(key)) {\n            if (typeof key.const === 'string' || typeof key.const === 'number') {\n                return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);\n            }\n            else\n                throw Error('TypeBuilder: Record key of type literal is not of type string or number');\n        }\n        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            const pattern = exports.PatternNumberExact;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else if (TypeGuard.TString(key)) {\n            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else {\n            throw Error(`StandardTypeBuilder: Record key is an invalid type`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (options.$id === undefined)\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */\n    Ref(schema, options = {}) {\n        if (schema.$id === undefined)\n            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: schema.$id });\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Required */\n    Required(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Optional':\n                    delete schema[exports.Modifier];\n                    break;\n                default:\n                    delete schema[exports.Modifier];\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            schema.required = globalThis.Object.keys(schema.properties);\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */\n    Rest(schema) {\n        if (TypeGuard.TTuple(schema)) {\n            if (schema.items === undefined)\n                return [];\n            return schema.items.map((schema) => TypeClone.Clone(schema, {}));\n        }\n        else {\n            return [TypeClone.Clone(schema, {})];\n        }\n    }\n    /** `[Standard]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Standard]` Creates a template literal type */\n    TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = (typeof unresolved === 'string')\n            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))\n            : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Standard]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        }\n        else {\n            const anyOf = union;\n            if (anyOf.length === 0)\n                return this.Never(options);\n            if (anyOf.length === 1)\n                return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'null', typeOf: 'BigInt' });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    /** `[Extended]` Creates a Constructor type */\n    Constructor(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'object', instanceOf: 'Date' });\n    }\n    /** `[Extended]` Creates a Function type */\n    Function(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[Extended]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'object', instanceOf: 'Promise', item: TypeClone.Clone(item, {}) });\n    }\n    /** `[Extended]` Creates a regular expression type */\n    RegEx(regex, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern: regex.source });\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'null', typeOf: 'Symbol' });\n    }\n    /** `[Extended]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'null', typeOf: 'Undefined' });\n    }\n    /** `[Extended]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'object', instanceOf: 'Uint8Array' });\n    }\n    /** `[Extended]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'null', typeOf: 'Void' });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.Type = new ExtendedTypeBuilder();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNpbmNsYWlyK3R5cGVib3hAMC4yOS42L25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC90eXBlYm94LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLG1CQUFtQixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLCtCQUErQixHQUFHLDhCQUE4QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLGlDQUFpQyxHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsZ0JBQWdCO0FBQ3IzQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQiwyQkFBMkIsT0FBTyx1QkFBdUI7QUFDekQsMEJBQTBCLE9BQU8sc0JBQXNCO0FBQ3ZELDBCQUEwQixPQUFPLHNCQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsc0JBQXNCLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IseUJBQXlCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQixtQkFBbUIsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUyxJQUFJO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckIsU0FBUyxJQUFJO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQyw0QkFBNEI7QUFDbEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsV0FBVztBQUN4RztBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsV0FBVztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEUsOENBQThDLG1CQUFtQjtBQUNqRSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQixtQkFBbUIsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBLENBQUMsb0JBQW9CLHFCQUFxQixxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSxzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEVBQUUsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSxzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEVBQUUsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHFCQUFxQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWtEO0FBQ3JFO0FBQ0E7QUFDQSxDQUFDLDZCQUE2Qiw4QkFBOEIsOEJBQThCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QiwrQkFBK0IsK0JBQStCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qiw2QkFBNkIsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsNkJBQTZCLDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLEVBQUUsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrQkFBK0IsZ0NBQWdDLGdDQUFnQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0Msa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLGdDQUFnQyxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQTZEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxRUFBcUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QixvRkFBb0YsR0FBRztBQUNwSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDZCQUE2Qix3REFBd0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELDBEQUEwRCx3QkFBd0I7QUFDbEYsd0RBQXdELHFEQUFxRCxLQUFLO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkVBQTJFLDBEQUEwRCxJQUFJLHlEQUF5RDtBQUNsTSw2QkFBNkIsNENBQTRDO0FBQ3pFO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkIsd0RBQXdEO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsaUdBQWlHLHdFQUF3RSxJQUFJO0FBQzdLO0FBQ0EsaUNBQWlDLHdHQUF3RztBQUN6STtBQUNBO0FBQ0EsaUNBQWlDLHdGQUF3RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx3QkFBd0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsNkJBQTZCLHlFQUF5RTtBQUN0RztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2Qiw4Q0FBOEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUF3QztBQUNyRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDZCQUE2QixrREFBa0Q7QUFDL0U7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkIsc0RBQXNEO0FBQ25GO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHNFQUFzRSxJQUFJO0FBQ3pLLHNFQUFzRSxrREFBa0QsR0FBRyxLQUFLO0FBQ2hJO0FBQ0EsaUNBQWlDLDJJQUEySTtBQUM1SztBQUNBO0FBQ0EsaUNBQWlDLG1IQUFtSDtBQUNwSjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyx5Q0FBeUMsR0FBRyxLQUFLO0FBQzNKLGdDQUFnQywyRUFBMkUseUNBQXlDLEtBQUs7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbURBQW1ELEdBQUcsS0FBSztBQUN0SSxpREFBaUQsc0NBQXNDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUMsR0FBRztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkVBQTJFLHFDQUFxQyxLQUFLO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyRUFBMkUscUNBQXFDLEtBQUs7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsb0NBQW9DLGlDQUFpQyxZQUFZLEdBQUc7QUFDcEY7QUFDQSw2QkFBNkIsc0RBQXNEO0FBQ25GO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QixxREFBcUQ7QUFDbEY7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkIsc0RBQXNEO0FBQ25GO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0VBQXdFO0FBQ3JHO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLGNBQWMsOEdBQThHO0FBQzVILGNBQWMsd0VBQXdFO0FBQ3RGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLGlDQUFpQyx5REFBeUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkIsK0RBQStEO0FBQzVGO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELDRGQUE0RjtBQUM1Riw2QkFBNkIsNElBQTRJO0FBQ3pLO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNkJBQTZCLHdFQUF3RTtBQUNyRztBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsNEZBQTRGO0FBQzVGLDZCQUE2QixzSUFBc0k7QUFDbks7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkIsNEdBQTRHLEdBQUc7QUFDNUk7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsNkVBQTZFO0FBQzFHO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCLDRFQUE0RTtBQUN6RztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QixvRkFBb0Y7QUFDakg7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw2QkFBNkIsa0VBQWtFO0FBQy9GO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVnYWwtc2VtYW50aWMtc2VhcmNoLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjkuNi9ub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvdHlwZWJveC5qcz8yNzEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5Ac2luY2xhaXIvdHlwZWJveFxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDE3LTIwMjMgSGF5ZG4gUGF0ZXJzb24gKHNpbmNsYWlyKSA8aGF5ZG4uZGV2ZWxvcGVyQGdtYWlsLmNvbT5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlID0gZXhwb3J0cy5TdGFuZGFyZFR5cGUgPSBleHBvcnRzLkV4dGVuZGVkVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlN0YW5kYXJkVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlR5cGVCdWlsZGVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsRmluaXRlID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IGV4cG9ydHMuVW5pb25SZXNvbHZlciA9IGV4cG9ydHMuS2V5QXJyYXlSZXNvbHZlciA9IGV4cG9ydHMuS2V5UmVzb2x2ZXIgPSBleHBvcnRzLk9iamVjdE1hcCA9IGV4cG9ydHMuSW5kZXhlZEFjY2Vzc29yID0gZXhwb3J0cy5UeXBlQ2xvbmUgPSBleHBvcnRzLlR5cGVFeHRlbmRzID0gZXhwb3J0cy5UeXBlRXh0ZW5kc1Jlc3VsdCA9IGV4cG9ydHMuRXh0ZW5kc1VuZGVmaW5lZCA9IGV4cG9ydHMuVHlwZUd1YXJkID0gZXhwb3J0cy5UeXBlR3VhcmRVbmtub3duVHlwZUVycm9yID0gZXhwb3J0cy5Gb3JtYXRSZWdpc3RyeSA9IGV4cG9ydHMuVHlwZVJlZ2lzdHJ5ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3QgPSBleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdCA9IGV4cG9ydHMuUGF0dGVybkJvb2xlYW5FeGFjdCA9IGV4cG9ydHMuUGF0dGVyblN0cmluZyA9IGV4cG9ydHMuUGF0dGVybk51bWJlciA9IGV4cG9ydHMuUGF0dGVybkJvb2xlYW4gPSBleHBvcnRzLktpbmQgPSBleHBvcnRzLkhpbnQgPSBleHBvcnRzLk1vZGlmaWVyID0gdm9pZCAwO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN5bWJvbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnRzLk1vZGlmaWVyID0gU3ltYm9sLmZvcignVHlwZUJveC5Nb2RpZmllcicpO1xuZXhwb3J0cy5IaW50ID0gU3ltYm9sLmZvcignVHlwZUJveC5IaW50Jyk7XG5leHBvcnRzLktpbmQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LktpbmQnKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXR0ZXJuc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuUGF0dGVybkJvb2xlYW4gPSAnKHRydWV8ZmFsc2UpJztcbmV4cG9ydHMuUGF0dGVybk51bWJlciA9ICcoMHxbMS05XVswLTldKiknO1xuZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gJyguKiknO1xuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybkJvb2xlYW59JGA7XG5leHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdCA9IGBeJHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9JGA7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGBeJHtleHBvcnRzLlBhdHRlcm5TdHJpbmd9JGA7XG4vKiogQSByZWdpc3RyeSBmb3IgdXNlciBkZWZpbmVkIHR5cGVzICovXG52YXIgVHlwZVJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChUeXBlUmVnaXN0cnkpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqIFJldHVybnMgdGhlIGVudHJpZXMgaW4gdGhpcyByZWdpc3RyeSAqL1xuICAgIGZ1bmN0aW9uIEVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKG1hcCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5FbnRyaWVzID0gRW50cmllcztcbiAgICAvKiogQ2xlYXJzIGFsbCB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbiAgICBmdW5jdGlvbiBDbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5jbGVhcigpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVnaXN0cnkgY29udGFpbnMgdGhpcyBraW5kICovXG4gICAgZnVuY3Rpb24gSGFzKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5oYXMoa2luZCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5IYXMgPSBIYXM7XG4gICAgLyoqIFNldHMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBhIHVzZXIgZGVmaW5lZCB0eXBlICovXG4gICAgZnVuY3Rpb24gU2V0KGtpbmQsIGZ1bmMpIHtcbiAgICAgICAgbWFwLnNldChraW5kLCBmdW5jKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LlNldCA9IFNldDtcbiAgICAvKiogR2V0cyBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBhIHVzZXIgZGVmaW5lZCB0eXBlICovXG4gICAgZnVuY3Rpb24gR2V0KGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoa2luZCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5HZXQgPSBHZXQ7XG59KShUeXBlUmVnaXN0cnkgfHwgKGV4cG9ydHMuVHlwZVJlZ2lzdHJ5ID0gVHlwZVJlZ2lzdHJ5ID0ge30pKTtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdHMgKi9cbnZhciBGb3JtYXRSZWdpc3RyeTtcbihmdW5jdGlvbiAoRm9ybWF0UmVnaXN0cnkpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqIFJldHVybnMgdGhlIGVudHJpZXMgaW4gdGhpcyByZWdpc3RyeSAqL1xuICAgIGZ1bmN0aW9uIEVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKG1hcCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkNsZWFyID0gQ2xlYXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgZXhpc3RzICovXG4gICAgZnVuY3Rpb24gSGFzKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhmb3JtYXQpO1xuICAgIH1cbiAgICBGb3JtYXRSZWdpc3RyeS5IYXMgPSBIYXM7XG4gICAgLyoqIFNldHMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBhIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0ICovXG4gICAgZnVuY3Rpb24gU2V0KGZvcm1hdCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGZvcm1hdCwgZnVuYyk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LlNldCA9IFNldDtcbiAgICAvKiogR2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBHZXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuZ2V0KGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKEZvcm1hdFJlZ2lzdHJ5IHx8IChleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gRm9ybWF0UmVnaXN0cnkgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVHdWFyZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKCdUeXBlR3VhcmQ6IFVua25vd24gdHlwZScpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBUeXBlR3VhcmRVbmtub3duVHlwZUVycm9yO1xuLyoqIFByb3ZpZGVzIGZ1bmN0aW9ucyB0byB0ZXN0IGlmIEphdmFTY3JpcHQgdmFsdWVzIGFyZSBUeXBlQm94IHR5cGVzICovXG52YXIgVHlwZUd1YXJkO1xuKGZ1bmN0aW9uIChUeXBlR3VhcmQpIHtcbiAgICBmdW5jdGlvbiBJc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUGF0dGVybih2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoKGNvZGUgPj0gNyAmJiBjb2RlIDw9IDEzKSB8fCBjb2RlID09PSAyNyB8fCBjb2RlID09PSAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQWRkaXRpb25hbFByb3BlcnRpZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB8fCBUU2NoZW1hKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCaWdJbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBnbG9iYWxUaGlzLk51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCaWdJbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgSXNCaWdJbnQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbE51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc051bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0Jvb2xlYW4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbFN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsUGF0dGVybih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkgJiYgSXNQYXR0ZXJuKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxGb3JtYXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgSXNTdHJpbmcodmFsdWUpICYmIElzQ29udHJvbENoYXJhY3RlckZyZWUodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbFNjaGVtYSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBUU2NoZW1hKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBbnkgKi9cbiAgICBmdW5jdGlvbiBUQW55KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FueScgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRBbnkgPSBUQW55O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQXJyYXkgKi9cbiAgICBmdW5jdGlvbiBUQXJyYXkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdBcnJheScgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBUU2NoZW1hKHNjaGVtYS5pdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkl0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4SXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5pcXVlSXRlbXMpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRBcnJheSA9IFRBcnJheTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEJpZ0ludCAqL1xuICAgIGZ1bmN0aW9uIFRCaWdJbnQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGVPZiA9PT0gJ0JpZ0ludCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm11bHRpcGxlT2YpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5taW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubWF4aW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UQmlnSW50ID0gVEJpZ0ludDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEJvb2xlYW4gKi9cbiAgICBmdW5jdGlvbiBUQm9vbGVhbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCb29sZWFuJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UQm9vbGVhbiA9IFRCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQ29uc3RydWN0b3IgKi9cbiAgICBmdW5jdGlvbiBUQ29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0NvbnN0cnVjdG9yJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ0NvbnN0cnVjdG9yJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNBcnJheShzY2hlbWEucGFyYW1ldGVycykgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLnJldHVybnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHNjaGVtYS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEocGFyYW1ldGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UQ29uc3RydWN0b3IgPSBUQ29uc3RydWN0b3I7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFREYXRlICovXG4gICAgZnVuY3Rpb24gVERhdGUoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdEYXRlJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5pbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4aW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5URGF0ZSA9IFREYXRlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBURnVuY3Rpb24gKi9cbiAgICBmdW5jdGlvbiBURnVuY3Rpb24oc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ0Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNBcnJheShzY2hlbWEucGFyYW1ldGVycykgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLnJldHVybnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHNjaGVtYS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEocGFyYW1ldGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5URnVuY3Rpb24gPSBURnVuY3Rpb247XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRJbnRlZ2VyICovXG4gICAgZnVuY3Rpb24gVEludGVnZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdJbnRlZ2VyJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdpbnRlZ2VyJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRJbnRlZ2VyID0gVEludGVnZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRJbnRlcnNlY3QgKi9cbiAgICBmdW5jdGlvbiBUSW50ZXJzZWN0KHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdJbnRlcnNlY3QnICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5hbGxPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLnR5cGUpICYmXG4gICAgICAgICAgICAoSXNPcHRpb25hbEJvb2xlYW4oc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcykgfHwgSXNPcHRpb25hbFNjaGVtYShzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCd0eXBlJyBpbiBzY2hlbWEgJiYgc2NoZW1hLnR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYWxsT2YpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVyc2VjdCA9IFRJbnRlcnNlY3Q7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRLaW5kICovXG4gICAgZnVuY3Rpb24gVEtpbmQoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIGV4cG9ydHMuS2luZCBpbiBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnc3RyaW5nJzsgLy8gVFMgNC4xLjU6IGFueSByZXF1aXJlZCBmb3Igc3ltYm9sIGluZGV4ZXJcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRLaW5kID0gVEtpbmQ7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPHN0cmluZz4gKi9cbiAgICBmdW5jdGlvbiBUTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRLaW5kKHNjaGVtYSkgJiYgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdMaXRlcmFsJyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxTdHJpbmcgPSBUTGl0ZXJhbFN0cmluZztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8bnVtYmVyPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsTnVtYmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbE51bWJlciA9IFRMaXRlcmFsTnVtYmVyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxib29sZWFuPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRLaW5kKHNjaGVtYSkgJiYgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdMaXRlcmFsJyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsQm9vbGVhbiA9IFRMaXRlcmFsQm9vbGVhbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWwgKi9cbiAgICBmdW5jdGlvbiBUTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkgfHwgVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB8fCBUTGl0ZXJhbEJvb2xlYW4oc2NoZW1hKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsID0gVExpdGVyYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFROZXZlciAqL1xuICAgIGZ1bmN0aW9uIFROZXZlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRLaW5kKHNjaGVtYSkgJiYgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOZXZlcicgJiYgSXNPYmplY3Qoc2NoZW1hLm5vdCkgJiYgZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzY2hlbWEubm90KS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTmV2ZXIgPSBUTmV2ZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFROb3QgKi9cbiAgICBmdW5jdGlvbiBUTm90KHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05vdCcgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLm5vdCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVE5vdCA9IFROb3Q7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFROdWxsICovXG4gICAgZnVuY3Rpb24gVE51bGwoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVE51bGwgPSBUTnVsbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bWJlciAqL1xuICAgIGZ1bmN0aW9uIFROdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdW1iZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4aW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVtYmVyID0gVE51bWJlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE9iamVjdCAqL1xuICAgIGZ1bmN0aW9uIFRPYmplY3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09iamVjdChzY2hlbWEucHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluUHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heFByb3BlcnRpZXMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCFJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UT2JqZWN0ID0gVE9iamVjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFByb21pc2UgKi9cbiAgICBmdW5jdGlvbiBUUHJvbWlzZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdQcm9taXNlJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBUU2NoZW1hKHNjaGVtYS5pdGVtKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUHJvbWlzZSA9IFRQcm9taXNlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUmVjb3JkICovXG4gICAgZnVuY3Rpb24gVFJlY29yZChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnUmVjb3JkJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNQYXR0ZXJuKGtleXNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFUU2NoZW1hKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1trZXlzWzBdXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWNvcmQgPSBUUmVjb3JkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUmVmICovXG4gICAgZnVuY3Rpb24gVFJlZihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWYnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlZiA9IFRSZWY7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTdHJpbmcgKi9cbiAgICBmdW5jdGlvbiBUU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3RyaW5nJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5MZW5ndGgpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhMZW5ndGgpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsUGF0dGVybihzY2hlbWEucGF0dGVybikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxGb3JtYXQoc2NoZW1hLmZvcm1hdCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN0cmluZyA9IFRTdHJpbmc7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTeW1ib2wgKi9cbiAgICBmdW5jdGlvbiBUU3ltYm9sKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdTeW1ib2wnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRTeW1ib2wgPSBUU3ltYm9sO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGVtcGxhdGVMaXRlcmFsICovXG4gICAgZnVuY3Rpb24gVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUZW1wbGF0ZUxpdGVyYWwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgc2NoZW1hLnBhdHRlcm5bMF0gPT09ICdeJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnBhdHRlcm5bc2NoZW1hLnBhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICckJyk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsID0gVFRlbXBsYXRlTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFRoaXMgKi9cbiAgICBmdW5jdGlvbiBUVGhpcyhzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUaGlzJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLiRyZWYpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUaGlzID0gVFRoaXM7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUdXBsZSAqL1xuICAgIGZ1bmN0aW9uIFRUdXBsZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVHVwbGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNOdW1iZXIoc2NoZW1hLm1pbkl0ZW1zKSAmJlxuICAgICAgICAgICAgSXNOdW1iZXIoc2NoZW1hLm1heEl0ZW1zKSAmJlxuICAgICAgICAgICAgc2NoZW1hLm1pbkl0ZW1zID09PSBzY2hlbWEubWF4SXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWEubWluSXRlbXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFR1cGxlID0gVFR1cGxlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5kZWZpbmVkICovXG4gICAgZnVuY3Rpb24gVFVuZGVmaW5lZChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnVW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkID0gVFVuZGVmaW5lZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVuaW9uPExpdGVyYWw8c3RyaW5nIHwgbnVtYmVyPltdPiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbkxpdGVyYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUVW5pb24oc2NoZW1hKSAmJiBzY2hlbWEuYW55T2YuZXZlcnkoKHNjaGVtYSkgPT4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmlvbkxpdGVyYWwgPSBUVW5pb25MaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBUVW5pb24oc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJyAmJlxuICAgICAgICAgICAgSXNBcnJheShzY2hlbWEuYW55T2YpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2Ygc2NoZW1hLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEoaW5uZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmlvbiA9IFRVbmlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVpbnQ4QXJyYXkgKi9cbiAgICBmdW5jdGlvbiBUVWludDhBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRLaW5kKHNjaGVtYSkgJiYgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVaW50OEFycmF5JyAmJiBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ1VpbnQ4QXJyYXknICYmIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkJ5dGVMZW5ndGgpICYmIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heEJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVpbnQ4QXJyYXkgPSBUVWludDhBcnJheTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVua25vd24gKi9cbiAgICBmdW5jdGlvbiBUVW5rbm93bihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmtub3duJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVW5rbm93biA9IFRVbmtub3duO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBhIHJhdyBUVW5zYWZlICovXG4gICAgZnVuY3Rpb24gVFVuc2FmZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbnNhZmUnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbnNhZmUgPSBUVW5zYWZlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVm9pZCAqL1xuICAgIGZ1bmN0aW9uIFRWb2lkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1ZvaWQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFZvaWQgPSBUVm9pZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHlPcHRpb25hbCBtb2RpZmllciAqL1xuICAgIGZ1bmN0aW9uIFRSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsID0gVFJlYWRvbmx5T3B0aW9uYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNjaGVtYSBoYXMgdGhlIFJlYWRvbmx5IG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdSZWFkb25seSc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVhZG9ubHkgPSBUUmVhZG9ubHk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNjaGVtYSBoYXMgdGhlIE9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdPcHRpb25hbCc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UT3B0aW9uYWwgPSBUT3B0aW9uYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTY2hlbWEgKi9cbiAgICBmdW5jdGlvbiBUU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoVEFueShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEFycmF5KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQm9vbGVhbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEJpZ0ludChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVENvbnN0cnVjdG9yKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURGF0ZShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEZ1bmN0aW9uKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZWdlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEludGVyc2VjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVExpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFROZXZlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5vdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bGwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFROdW1iZXIoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRPYmplY3Qoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRQcm9taXNlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUUmVjb3JkKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUUmVmKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUU3RyaW5nKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUU3ltYm9sKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVGhpcyhzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFR1cGxlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5kZWZpbmVkKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5pb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVaW50OEFycmF5KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5rbm93bihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVuc2FmZShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFZvaWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIChUS2luZChzY2hlbWEpICYmIFR5cGVSZWdpc3RyeS5IYXMoc2NoZW1hW2V4cG9ydHMuS2luZF0pKSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFNjaGVtYSA9IFRTY2hlbWE7XG59KShUeXBlR3VhcmQgfHwgKGV4cG9ydHMuVHlwZUd1YXJkID0gVHlwZUd1YXJkID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHRlbmRzVW5kZWZpbmVkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIEZhc3QgdW5kZWZpbmVkIGNoZWNrIHVzZWQgZm9yIHByb3BlcnRpZXMgb2YgdHlwZSB1bmRlZmluZWQgKi9cbnZhciBFeHRlbmRzVW5kZWZpbmVkO1xuKGZ1bmN0aW9uIChFeHRlbmRzVW5kZWZpbmVkKSB7XG4gICAgZnVuY3Rpb24gQ2hlY2soc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90Jykge1xuICAgICAgICAgICAgcmV0dXJuICFDaGVjayhzY2hlbWEubm90KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdJbnRlcnNlY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBzY2hlbWE7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0LmFsbE9mLmV2ZXJ5KChzY2hlbWEpID0+IENoZWNrKHNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJykge1xuICAgICAgICAgICAgY29uc3QgdW5pb24gPSBzY2hlbWE7XG4gICAgICAgICAgICByZXR1cm4gdW5pb24uYW55T2Yuc29tZSgoc2NoZW1hKSA9PiBDaGVjayhzY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIEV4dGVuZHNVbmRlZmluZWQuQ2hlY2sgPSBDaGVjaztcbn0pKEV4dGVuZHNVbmRlZmluZWQgfHwgKGV4cG9ydHMuRXh0ZW5kc1VuZGVmaW5lZCA9IEV4dGVuZHNVbmRlZmluZWQgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVFeHRlbmRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFR5cGVFeHRlbmRzUmVzdWx0O1xuKGZ1bmN0aW9uIChUeXBlRXh0ZW5kc1Jlc3VsdCkge1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiVW5pb25cIl0gPSAwXSA9IFwiVW5pb25cIjtcbiAgICBUeXBlRXh0ZW5kc1Jlc3VsdFtUeXBlRXh0ZW5kc1Jlc3VsdFtcIlRydWVcIl0gPSAxXSA9IFwiVHJ1ZVwiO1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiRmFsc2VcIl0gPSAyXSA9IFwiRmFsc2VcIjtcbn0pKFR5cGVFeHRlbmRzUmVzdWx0IHx8IChleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gVHlwZUV4dGVuZHNSZXN1bHQgPSB7fSkpO1xudmFyIFR5cGVFeHRlbmRzO1xuKGZ1bmN0aW9uIChUeXBlRXh0ZW5kcykge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gSW50b0Jvb2xlYW5SZXN1bHRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludG9Cb29sZWFuUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlIDogVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBbnlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBbnkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSAmJiByaWdodC5hbnlPZi5zb21lKChzY2hlbWEpID0+IFR5cGVHdWFyZC5UQW55KHNjaGVtYSkgfHwgVHlwZUd1YXJkLlRVbmtub3duKHNjaGVtYSkpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQXJyYXlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEFycmF5UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFycmF5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQobGVmdC5pdGVtcywgcmlnaHQuaXRlbXMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCaWdJbnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEJpZ0ludChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJpZ0ludChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQm9vbGVhblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgdHlwZW9mIGxlZnQuY29uc3QgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCb29sZWFuKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCb29sZWFuKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVENvbnN0cnVjdG9yKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKGxlZnQucGFyYW1ldGVycy5sZW5ndGggPiByaWdodC5wYXJhbWV0ZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKCFsZWZ0LnBhcmFtZXRlcnMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHJpZ2h0LnBhcmFtZXRlcnNbaW5kZXhdLCBzY2hlbWEpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQobGVmdC5yZXR1cm5zLCByaWdodC5yZXR1cm5zKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gRGF0ZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlREYXRlKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBGdW5jdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gRnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5URnVuY3Rpb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5wYXJhbWV0ZXJzLmxlbmd0aCA+IHJpZ2h0LnBhcmFtZXRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoIWxlZnQucGFyYW1ldGVycy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQocmlnaHQucGFyYW1ldGVyc1tpbmRleF0sIHNjaGVtYSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LnJldHVybnMsIHJpZ2h0LnJldHVybnMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRlZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpIHx8IFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZWdlcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRlcnNlY3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiByaWdodC5hbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBWaXNpdChsZWZ0LCBzY2hlbWEpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmFsbE9mLnNvbWUoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIExpdGVyYWxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsQm9vbGVhbihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gTGl0ZXJhbChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UTGl0ZXJhbChyaWdodCkgJiYgcmlnaHQuY29uc3QgPT09IGxlZnQuY29uc3QgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTmV2ZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOZXZlcihsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOb3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVud3JhcE5vdChzY2hlbWEpIHtcbiAgICAgICAgbGV0IFtjdXJyZW50LCBkZXB0aF0gPSBbc2NoZW1hLCAwXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICghVHlwZUd1YXJkLlROb3QoY3VycmVudCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5ub3Q7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aCAlIDIgPT09IDAgPyBjdXJyZW50IDogZXhwb3J0cy5UeXBlLlVua25vd24oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTm90KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgaGFzIG5vIGNvbmNlcHQgb2YgbmVnYXRlZCB0eXBlcywgYW5kIGF0dGVtcHRzIHRvIGNvcnJlY3RseSBjaGVjayB0aGUgbmVnYXRlZFxuICAgICAgICAvLyB0eXBlIGF0IHJ1bnRpbWUgd291bGQgcHV0IFR5cGVCb3ggYXQgb2RkcyB3aXRoIFR5cGVTY3JpcHRzIGFiaWxpdHkgdG8gc3RhdGljYWxseSBpbmZlclxuICAgICAgICAvLyB0aGUgdHlwZS4gSW5zdGVhZCB3ZSB1bndyYXAgdG8gZWl0aGVyIHVua25vd24gb3IgVCBhbmQgY29udGludWUgZXZhbHVhdGluZy5cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTm90KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KFVud3JhcE5vdChsZWZ0KSwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROb3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFVud3JhcE5vdChyaWdodCkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVFeHRlbmRzOiBJbnZhbGlkIGZhbGx0aHJvdWdoIGZvciBOb3RgKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOdWxsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBOdWxsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UTnVsbChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTnVtYmVyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBOdW1iZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbE51bWJlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgfHwgVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOdW1iZXIobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSB8fCBUeXBlR3VhcmQuVE51bWJlcihyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gT2JqZWN0XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCBjb3VudCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykubGVuZ3RoID09PSBjb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RTdHJpbmdMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RBcnJheUxpa2Uoc2NoZW1hKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RTeW1ib2xMaWtlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApIHx8IChJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAxKSAmJiAnZGVzY3JpcHRpb24nIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24pICYmIHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mLmxlbmd0aCA9PT0gMiAmJiAoKFR5cGVHdWFyZC5UU3RyaW5nKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzBdKSAmJlxuICAgICAgICAgICAgVHlwZUd1YXJkLlRVbmRlZmluZWQoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMV0pKSB8fCAoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMV0pICYmXG4gICAgICAgICAgICBUeXBlR3VhcmQuVFVuZGVmaW5lZChzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlswXSkpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0TnVtYmVyTGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdEJvb2xlYW5MaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0QmlnSW50TGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdERhdGVMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0VWludDhBcnJheUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdEZ1bmN0aW9uTGlrZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdsZW5ndGgnIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWydsZW5ndGgnXSwgbGVuZ3RoKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdENvbnN0cnVjdG9yTGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdsZW5ndGgnIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWydsZW5ndGgnXSwgbGVuZ3RoKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFByb21pc2VMaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCB0aGVuID0gZXhwb3J0cy5UeXBlLkZ1bmN0aW9uKFtleHBvcnRzLlR5cGUuQW55KCldLCBleHBvcnRzLlR5cGUuQW55KCkpO1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICd0aGVuJyBpbiBzY2hlbWEucHJvcGVydGllcyAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChzY2hlbWEucHJvcGVydGllc1sndGhlbiddLCB0aGVuKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFByb3BlcnR5XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBQcm9wZXJ0eShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVmlzaXQobGVmdCwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT3B0aW9uYWwobGVmdCkgJiYgIVR5cGVHdWFyZC5UT3B0aW9uYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbFN0cmluZyhsZWZ0KSAmJiBJc09iamVjdFN0cmluZ0xpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsTnVtYmVyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxCb29sZWFuKGxlZnQpICYmIElzT2JqZWN0Qm9vbGVhbkxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN5bWJvbChsZWZ0KSAmJiBJc09iamVjdFN5bWJvbExpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJpZ0ludChsZWZ0KSAmJiBJc09iamVjdEJpZ0ludExpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSAmJiBJc09iamVjdFN0cmluZ0xpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN5bWJvbChsZWZ0KSAmJiBJc09iamVjdFN5bWJvbExpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKGxlZnQpICYmIElzT2JqZWN0Qm9vbGVhbkxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkgJiYgSXNPYmplY3RVaW50OEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5URGF0ZShsZWZ0KSAmJiBJc09iamVjdERhdGVMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRDb25zdHJ1Y3RvcihsZWZ0KSAmJiBJc09iamVjdENvbnN0cnVjdG9yTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5URnVuY3Rpb24obGVmdCkgJiYgSXNPYmplY3RGdW5jdGlvbkxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChsZWZ0KSAmJiBUeXBlR3VhcmQuVFN0cmluZyhSZWNvcmRLZXkobGVmdCkpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGV4cHJlc3NpbmcgYSBSZWNvcmQgd2l0aCBsaXRlcmFsIGtleSB2YWx1ZXMsIHRoZSBSZWNvcmQgaXMgY29udmVydGVkIGludG8gYSBPYmplY3Qgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIEhpbnQgYXNzaWduZWQgYXMgYFJlY29yZGAuIFRoaXMgaXMgdXNlZCB0byBpbnZlcnQgdGhlIGV4dGVuZHMgbG9naWMuXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRbZXhwb3J0cy5IaW50XSA9PT0gJ1JlY29yZCcgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpICYmIFR5cGVHdWFyZC5UTnVtYmVyKFJlY29yZEtleShsZWZ0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQocmlnaHQsIDApID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMocmlnaHQucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBsZWZ0LnByb3BlcnRpZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgIGlmIChQcm9wZXJ0eShsZWZ0LnByb3BlcnRpZXNba2V5XSwgcmlnaHQucHJvcGVydGllc1trZXldKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvbWlzZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUHJvbWlzZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdFByb21pc2VMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UUHJvbWlzZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0Lml0ZW0sIHJpZ2h0Lml0ZW0pKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZWNvcmRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFJlY29yZEtleShzY2hlbWEpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICB0aHJvdyBFcnJvcignVHlwZUV4dGVuZHM6IENhbm5vdCBnZXQgcmVjb3JkIGtleScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmRWYWx1ZShzY2hlbWEpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3RdO1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1tleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdF07XG4gICAgICAgIHRocm93IEVycm9yKCdUeXBlRXh0ZW5kczogQ2Fubm90IGdldCByZWNvcmQgdmFsdWUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgS2V5ID0gUmVjb3JkS2V5KHJpZ2h0KTtcbiAgICAgICAgY29uc3QgVmFsdWUgPSBSZWNvcmRWYWx1ZShyaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsU3RyaW5nKGxlZnQpICYmIFR5cGVHdWFyZC5UTnVtYmVyKEtleSkgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQobGVmdCwgVmFsdWUpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpICYmIFR5cGVHdWFyZC5UTnVtYmVyKEtleSkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVmFsdWUpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KGxlZnQpICYmIFR5cGVHdWFyZC5UTnVtYmVyKEtleSkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVmFsdWUpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QobGVmdCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMobGVmdC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChQcm9wZXJ0eShWYWx1ZSwgbGVmdC5wcm9wZXJ0aWVzW2tleV0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgVmFsdWUgPSBSZWNvcmRWYWx1ZShsZWZ0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIFZpc2l0KFZhbHVlLCBSZWNvcmRWYWx1ZShyaWdodCkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTdHJpbmcobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTdHJpbmcocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN5bWJvbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gU3ltYm9sKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UU3ltYm9sKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUZW1wbGF0ZUxpdGVyYWxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChsZWZ0LCByaWdodCkge1xuICAgICAgICAvLyBUZW1wbGF0ZUxpdGVyYWwgdHlwZXMgYXJlIHJlc29sdmVkIHRvIGVpdGhlciB1bmlvbnMgZm9yIGZpbml0ZSBleHByZXNzaW9ucyBvciBzdHJpbmdcbiAgICAgICAgLy8gZm9yIGluZmluaXRlIGV4cHJlc3Npb25zLiBIZXJlIHdlIGNhbGwgdG8gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIgdG8gcmVzb2x2ZSBmb3JcbiAgICAgICAgLy8gZWl0aGVyIHR5cGUgYW5kIGNvbnRpbnVlIGV2YWx1YXRpbmcuXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShyaWdodCkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVFeHRlbmRzOiBJbnZhbGlkIGZhbGx0aHJvdWdoIGZvciBUZW1wbGF0ZUxpdGVyYWxgKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUdXBsZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVHVwbGVSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheU9mVHVwbGUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpICYmIGxlZnQuaXRlbXMgIT09IHVuZGVmaW5lZCAmJiBsZWZ0Lml0ZW1zLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQuaXRlbXMpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHVwbGUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KHJpZ2h0KSAmJiBJc0FycmF5T2ZUdXBsZShsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVFR1cGxlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKChsZWZ0Lml0ZW1zID09PSB1bmRlZmluZWQgJiYgcmlnaHQuaXRlbXMgIT09IHVuZGVmaW5lZCkgfHwgKGxlZnQuaXRlbXMgIT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKGxlZnQuaXRlbXMgPT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBsZWZ0Lml0ZW1zLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0Lml0ZW1zW2luZGV4XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFVpbnQ4QXJyYXlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVpbnQ4QXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UVWludDhBcnJheShyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5kZWZpbmVkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmRlZmluZWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRWb2lkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBWb2lkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmRlZmluZWQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFVuaW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiByaWdodC5hbnlPZi5zb21lKChzY2hlbWEpID0+IFZpc2l0KGxlZnQsIHNjaGVtYSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdC5hbnlPZi5ldmVyeSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5rbm93blxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTdHJpbmcocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1JpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW5SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBcnJheVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVHVwbGUocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR1cGxlUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVm9pZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVm9pZFJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZvaWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRWb2lkKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgLy8gUmVzb2x2YWJsZSBUeXBlc1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwobGVmdCkgfHwgVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5vdChsZWZ0KSB8fCBUeXBlR3VhcmQuVE5vdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTm90KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgLy8gU3RhbmRhcmQgVHlwZXNcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQmlnSW50KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVENvbnN0cnVjdG9yKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5URGF0ZShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBEYXRlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5URnVuY3Rpb24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBMaXRlcmFsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdWxsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bGwobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFN5bWJvbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR1cGxlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUHJvbWlzZShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuZGVmaW5lZChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVm9pZChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBWb2lkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFR5cGVFeHRlbmRzOiBVbmtub3duIGxlZnQgdHlwZSBvcGVyYW5kICcke2xlZnRbZXhwb3J0cy5LaW5kXX0nYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEV4dGVuZHMobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgVHlwZUV4dGVuZHMuRXh0ZW5kcyA9IEV4dGVuZHM7XG59KShUeXBlRXh0ZW5kcyB8fCAoZXhwb3J0cy5UeXBlRXh0ZW5kcyA9IFR5cGVFeHRlbmRzID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlQ2xvbmVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogU3BlY2lhbGl6ZWQgQ2xvbmUgZm9yIFR5cGVzICovXG52YXIgVHlwZUNsb25lO1xuKGZ1bmN0aW9uIChUeXBlQ2xvbmUpIHtcbiAgICBmdW5jdGlvbiBJc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsdWUpID0+IFZpc2l0KHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCBba2V5XTogVmlzaXQodmFsdWVba2V5XSkgfTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBjbG9uZWRTeW1ib2xzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBWaXNpdCh2YWx1ZVtrZXldKSB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiB7IC4uLmNsb25lZFByb3BlcnRpZXMsIC4uLmNsb25lZFN5bWJvbHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQodmFsdWUpIHtcbiAgICAgICAgaWYgKElzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKElzT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBDbG9uZXMgYSB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIENsb25lKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4geyAuLi5WaXNpdChzY2hlbWEpLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIFR5cGVDbG9uZS5DbG9uZSA9IENsb25lO1xufSkoVHlwZUNsb25lIHx8IChleHBvcnRzLlR5cGVDbG9uZSA9IFR5cGVDbG9uZSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSW5kZXhlZEFjY2Vzc29yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEluZGV4ZWRBY2Nlc3NvcjtcbihmdW5jdGlvbiAoSW5kZXhlZEFjY2Vzc29yKSB7XG4gICAgZnVuY3Rpb24gT3B0aW9uYWxVbndyYXAoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEubWFwKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgW2V4cG9ydHMuTW9kaWZpZXJdOiBfLCAuLi5jbG9uZSB9ID0gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNJbnRlcnNlY3RPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ldmVyeSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHNjaGVtYSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1VuaW9uT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuc29tZSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHNjaGVtYSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNvbHZlSW50ZXJzZWN0KHNjaGVtYSkge1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IElzSW50ZXJzZWN0T3B0aW9uYWwoc2NoZW1hLmFsbE9mKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gZXhwb3J0cy5UeXBlLk9wdGlvbmFsKGV4cG9ydHMuVHlwZS5JbnRlcnNlY3QoT3B0aW9uYWxVbndyYXAoc2NoZW1hLmFsbE9mKSkpIDogc2NoZW1hO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNvbHZlVW5pb24oc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gSXNVbmlvbk9wdGlvbmFsKHNjaGVtYS5hbnlPZik7XG4gICAgICAgIHJldHVybiBvcHRpb25hbCA/IGV4cG9ydHMuVHlwZS5PcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24oT3B0aW9uYWxVbndyYXAoc2NoZW1hLmFueU9mKSkpIDogc2NoZW1hO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNvbHZlT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpXG4gICAgICAgICAgICByZXR1cm4gUmVzb2x2ZUludGVyc2VjdChzY2hlbWEpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gUmVzb2x2ZVVuaW9uKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHNjaGVtYS5hbGxPZi5yZWR1Y2UoKGFjYywgc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleGVkID0gVmlzaXQoc2NoZW1hLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyA/IGFjYyA6IFsuLi5hY2MsIGluZGV4ZWRdO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBSZXNvbHZlT3B0aW9uYWwoZXhwb3J0cy5UeXBlLkludGVyc2VjdChyZXNvbHZlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCBrZXkpKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24ocmVzb2x2ZWQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gc2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5ID09PSB1bmRlZmluZWQgPyBleHBvcnRzLlR5cGUuTmV2ZXIoKSA6IGV4cG9ydHMuVHlwZS5VbmlvbihbcHJvcGVydHldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHVwbGUoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXM7XG4gICAgICAgIGlmIChpdGVtcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaXRlbXNba2V5XTsgLy9cbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0KHNjaGVtYSwga2V5KTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKHNjaGVtYSwga2V5KTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUdXBsZScpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGUoc2NoZW1hLCBrZXkpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmUoc2NoZW1hLCBrZXlzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBrZXlzLm1hcCgoa2V5KSA9PiBWaXNpdChzY2hlbWEsIGtleS50b1N0cmluZygpKSk7XG4gICAgICAgIHJldHVybiBSZXNvbHZlT3B0aW9uYWwoZXhwb3J0cy5UeXBlLlVuaW9uKHJlc29sdmVkLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKEluZGV4ZWRBY2Nlc3NvciB8fCAoZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBJbmRleGVkQWNjZXNzb3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdE1hcFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBPYmplY3RNYXA7XG4oZnVuY3Rpb24gKE9iamVjdE1hcCkge1xuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLkludGVyc2VjdChzY2hlbWEuYWxsT2YubWFwKChpbm5lcikgPT4gVmlzaXQoaW5uZXIsIGNhbGxiYWNrKSksIHsgLi4uc2NoZW1hIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlVuaW9uKHNjaGVtYS5hbnlPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB1c2VycyBuZWVkIHRvIG1hcCBvYmplY3RzIHdpdGggdW5yZWdpc3RlcmVkIGtpbmRzLiBVc2luZyBhIFR5cGVHdWFyZCBoZXJlIHdvdWxkXG4gICAgICAgIC8vIHByZXZlbnQgc3ViIHNjaGVtYSBtYXBwaW5nIGFzIHVucmVnaXN0ZXJlZCBraW5kcyB3aWxsIG5vdCBwYXNzIFRTY2hlbWEgY2hlY2tzLiBUaGlzIGlzIG5vdGFibGUgaW4gdGhlXG4gICAgICAgIC8vIGNhc2Ugb2YgVE9iamVjdCB3aGVyZSB1bnJlZ2lzdGVyZWQgcHJvcGVydHkga2luZHMgY2F1c2UgdGhlIFRPYmplY3QgY2hlY2sgdG8gZmFpbC4gQXMgbWFwcGluZyBpcyBvbmx5XG4gICAgICAgIC8vIHVzZWQgZm9yIGNvbXBvc2l0aW9uLCB3ZSB1c2UgZXhwbGljaXQgY2hlY2tzIGluc3RlYWQuXG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ09iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNYXAoc2NoZW1hLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4geyAuLi5WaXNpdChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIGNhbGxiYWNrKSwgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBPYmplY3RNYXAuTWFwID0gTWFwO1xufSkoT2JqZWN0TWFwIHx8IChleHBvcnRzLk9iamVjdE1hcCA9IE9iamVjdE1hcCA9IHt9KSk7XG52YXIgS2V5UmVzb2x2ZXI7XG4oZnVuY3Rpb24gKEtleVJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24gVW53cmFwUGF0dGVybihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleVswXSA9PT0gJ14nICYmIGtleVtrZXkubGVuZ3RoIC0gMV0gPT09ICckJyA/IGtleS5zbGljZSgxLCBrZXkubGVuZ3RoIC0gMSkgOiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5yZWR1Y2UoKGFjYywgc2NoZW1hKSA9PiBbLi4uYWNjLCAuLi5WaXNpdChzY2hlbWEsIG9wdGlvbnMpXSwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IHNjaGVtYS5hbnlPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gWy4uLnNldHMucmVkdWNlKChzZXQsIG91dGVyKSA9PiBvdXRlci5tYXAoKGtleSkgPT4gKHNldHMuZXZlcnkoKGlubmVyKSA9PiBpbm5lci5pbmNsdWRlcyhrZXkpKSA/IHNldC5hZGQoa2V5KSA6IHNldCkpWzBdLCBuZXcgU2V0KCkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW5jbHVkZVBhdHRlcm5zID8gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIDogW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3Qoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3Qoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqIFJlc29sdmVzIGFuIGFycmF5IG9mIGtleXMgaW4gdGhpcyBzY2hlbWEgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlS2V5cyhzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KFZpc2l0KHNjaGVtYSwgb3B0aW9ucykpXTtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZUtleXMgPSBSZXNvbHZlS2V5cztcbiAgICAvKiogUmVzb2x2ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBtYXRjaGluZyBhbGwga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVQYXR0ZXJuKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBrZXlzID0gUmVzb2x2ZUtleXMoc2NoZW1hLCB7IGluY2x1ZGVQYXR0ZXJuczogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleXMubWFwKChrZXkpID0+IGAoJHtVbndyYXBQYXR0ZXJuKGtleSl9KWApO1xuICAgICAgICByZXR1cm4gYF4oJHtwYXR0ZXJuLmpvaW4oJ3wnKX0pJGA7XG4gICAgfVxuICAgIEtleVJlc29sdmVyLlJlc29sdmVQYXR0ZXJuID0gUmVzb2x2ZVBhdHRlcm47XG59KShLZXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlSZXNvbHZlciA9IEtleVJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBLZXlBcnJheVJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEtleUFycmF5UmVzb2x2ZXI7XG4oZnVuY3Rpb24gKEtleUFycmF5UmVzb2x2ZXIpIHtcbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Ygc3RyaW5nW10ga2V5cyBmcm9tIHRoZSBnaXZlbiBzY2hlbWEgb3IgYXJyYXkgdHlwZS4gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbkxpdGVyYWwoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuYW55T2YubWFwKChzY2hlbWEpID0+IHNjaGVtYS5jb25zdC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFtzY2hlbWEuY29uc3RdO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KHNjaGVtYS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmICghVGVtcGxhdGVMaXRlcmFsRmluaXRlLkNoZWNrKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdLZXlBcnJheVJlc29sdmVyOiBDYW5ub3QgcmVzb2x2ZSBrZXlzIGZyb20gaW5maW5pdGUgdGVtcGxhdGUgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKEtleUFycmF5UmVzb2x2ZXIgfHwgKGV4cG9ydHMuS2V5QXJyYXlSZXNvbHZlciA9IEtleUFycmF5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuaW9uUmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVW5pb25SZXNvbHZlcjtcbihmdW5jdGlvbiAoVW5pb25SZXNvbHZlcikge1xuICAgIGZ1bmN0aW9uKiBVbmlvbih1bmlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB1bmlvbi5hbnlPZikge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFVuaW9uKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSByZXNvbHZlZCB1bmlvbiB3aXRoIGludGVyaW9yIHVuaW9ucyBmbGF0dGVuZWQgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHVuaW9uKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oWy4uLlVuaW9uKHVuaW9uKV0sIHsgLi4udW5pb24gfSk7XG4gICAgfVxuICAgIFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZSA9IFJlc29sdmU7XG59KShVbmlvblJlc29sdmVyIHx8IChleHBvcnRzLlVuaW9uUmVzb2x2ZXIgPSBVbmlvblJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm47XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4pIHtcbiAgICBmdW5jdGlvbiBFc2NhcGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgYWNjKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2NoZW1hLnBhdHRlcm4uc2xpY2UoMSwgc2NoZW1hLnBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFVuaW9uKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCBhY2MpKS5qb2luKCd8Jyk7XG4gICAgICAgICAgICByZXR1cm4gYCgke3Rva2Vuc30pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVE51bWJlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuTnVtYmVyfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEJpZ0ludChzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuTnVtYmVyfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVyblN0cmluZ31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7RXNjYXBlKHNjaGVtYS5jb25zdC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTmV2ZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFRlbXBsYXRlTGl0ZXJhbCBjYW5ub3Qgb3BlcmF0ZSBvbiB0eXBlcyBvZiBUTmV2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuOiBVbmV4cGVjdGVkIEtpbmQgJyR7c2NoZW1hW2V4cG9ydHMuS2luZF19J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZShraW5kcykge1xuICAgICAgICByZXR1cm4gYF4ke2tpbmRzLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsICcnKSkuam9pbignJyl9XFwkYDtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUgPSBDcmVhdGU7XG59KShUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIpIHtcbiAgICAvKiogUmVzb2x2ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGEgVFVuaW9uICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QodGVtcGxhdGUucGF0dGVybik7XG4gICAgICAgIGlmICghVGVtcGxhdGVMaXRlcmFsRmluaXRlLkNoZWNrKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBbLi4uVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlKGV4cHJlc3Npb24pXS5tYXAoKHZhbHVlKSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbCh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSA9IFJlc29sdmU7XG59KShUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciA9IFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcjtcbnZhciBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbFBhcnNlcikge1xuICAgIGZ1bmN0aW9uIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgY2hhcikge1xuICAgICAgICByZXR1cm4gcGF0dGVybltpbmRleF0gPT09IGNoYXIgJiYgcGF0dGVybi5jaGFyQ29kZUF0KGluZGV4IC0gMSkgIT09IDkyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgJyknKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTZXBhcmF0b3IocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgJ3wnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNHcm91cChwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghKElzT3BlblBhcmVuKHBhdHRlcm4sIDApICYmIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwICYmIGluZGV4ICE9PSBwYXR0ZXJuLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbkdyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc2xpY2UoMSwgcGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQcmVjZWRlbmNlT3IocGF0dGVybikge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoSXNTZXBhcmF0b3IocGF0dGVybiwgaW5kZXgpICYmIGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQcmVjZWRlbmNlQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT3IocGF0dGVybikge1xuICAgICAgICBsZXQgW2NvdW50LCBzdGFydF0gPSBbMCwgMF07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHBhdHRlcm4uc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCk7XG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2NvbnN0JywgY29uc3Q6ICcnIH07XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdvcicsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFuZChwYXR0ZXJuKSB7XG4gICAgICAgIGZ1bmN0aW9uIEdyb3VwKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFJc09wZW5QYXJlbih2YWx1ZSwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBJbmRleCBtdXN0IHBvaW50IHRvIG9wZW4gcGFyZW5zYCk7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuIDwgdmFsdWUubGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4odmFsdWUsIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4odmFsdWUsIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpbmRleCwgc2Nhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjogVW5jbG9zZWQgZ3JvdXAgcGFyZW5zIGluIGV4cHJlc3Npb25gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBSYW5nZShwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuIDwgcGF0dGVybi5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBzY2FuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpbmRleCwgc2Nhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2luZGV4LCBwYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gR3JvdXAocGF0dGVybiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gUmFuZ2UocGF0dGVybiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2NvbnN0JywgY29uc3Q6ICcnIH07XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdhbmQnLCBleHByOiBleHByZXNzaW9ucyB9O1xuICAgIH1cbiAgICAvKiogUGFyc2VzIGEgcGF0dGVybiBhbmQgcmV0dXJucyBhbiBleHByZXNzaW9uIHRyZWUgKi9cbiAgICBmdW5jdGlvbiBQYXJzZShwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChJc0dyb3VwKHBhdHRlcm4pKVxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlKEluR3JvdXAocGF0dGVybikpO1xuICAgICAgICBpZiAoSXNQcmVjZWRlbmNlT3IocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gT3IocGF0dGVybik7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VBbmQocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gQW5kKHBhdHRlcm4pO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogcGF0dGVybiB9O1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2UgPSBQYXJzZTtcbiAgICAvKiogUGFyc2VzIGEgcGF0dGVybiBhbmQgc3RyaXBzIGZvcndhcmQgYW5kIHRyYWlsaW5nIF4gYW5kICQgKi9cbiAgICBmdW5jdGlvbiBQYXJzZUV4YWN0KHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIFBhcnNlKHBhdHRlcm4uc2xpY2UoMSwgcGF0dGVybi5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0ID0gUGFyc2VFeGFjdDtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhcnNlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXIgPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSkge1xuICAgIGZ1bmN0aW9uIElzTnVtYmVyKGV4cHJlc3Npb24pIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHIubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLmNvbnN0ID09PSAnMCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0uY29uc3QgPT09ICdbMS05XVswLTldKicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0Jvb2xlYW4oZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICd0cnVlJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ2ZhbHNlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzU3RyaW5nKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JyAmJiBleHByZXNzaW9uLmNvbnN0ID09PSAnLionO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDaGVjayhleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChJc0Jvb2xlYW4oZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKElzTnVtYmVyKGV4cHJlc3Npb24pIHx8IElzU3RyaW5nKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV4cHIuZXZlcnkoKGV4cHIpID0+IENoZWNrKGV4cHIpKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJylcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV4cHIuZXZlcnkoKGV4cHIpID0+IENoZWNrKGV4cHIpKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBFcnJvcihgVGVtcGxhdGVMaXRlcmFsRmluaXRlOiBVbmtub3duIGV4cHJlc3Npb24gdHlwZWApO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2sgPSBDaGVjaztcbn0pKFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uKiBSZWR1Y2UoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBidWZmZXJbMF07XG4gICAgICAgIGZvciAoY29uc3QgbGVmdCBvZiBidWZmZXJbMF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmlnaHQgb2YgUmVkdWNlKGJ1ZmZlci5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBgJHtsZWZ0fSR7cmlnaHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogQW5kKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBSZWR1Y2UoZXhwcmVzc2lvbi5leHByLm1hcCgoZXhwcikgPT4gWy4uLkdlbmVyYXRlKGV4cHIpXSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogT3IoZXhwcmVzc2lvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwcmVzc2lvbi5leHByKVxuICAgICAgICAgICAgeWllbGQqIEdlbmVyYXRlKGV4cHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogQ29uc3QoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQgZXhwcmVzc2lvbi5jb25zdDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIEdlbmVyYXRlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2FuZCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIEFuZChleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogT3IoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdjb25zdCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIENvbnN0KGV4cHJlc3Npb24pO1xuICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yOiBVbmtub3duIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlID0gR2VuZXJhdGU7XG59KShUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXI7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcikge1xuICAgIGZ1bmN0aW9uKiBQYXJzZVVuaW9uKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IHRyaW0gPSB0ZW1wbGF0ZS50cmltKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICAgIGlmICh0cmltID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJvb2xlYW4oKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5CaWdJbnQoKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSB0cmltLnNwbGl0KCd8JykubWFwKChsaXRlcmFsKSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChsaXRlcmFsLnRyaW0oKSkpO1xuICAgICAgICByZXR1cm4geWllbGQgbGl0ZXJhbHMubGVuZ3RoID09PSAwID8gZXhwb3J0cy5UeXBlLk5ldmVyKCkgOiBsaXRlcmFscy5sZW5ndGggPT09IDEgPyBsaXRlcmFsc1swXSA6IGV4cG9ydHMuVHlwZS5VbmlvbihsaXRlcmFscyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBQYXJzZVRlcm1pbmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVsxXSAhPT0gJ3snKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gZXhwb3J0cy5UeXBlLkxpdGVyYWwoJyQnKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQYXJzZUxpdGVyYWwodGVtcGxhdGUuc2xpY2UoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0ZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlW2ldID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBMID0gUGFyc2VVbmlvbih0ZW1wbGF0ZS5zbGljZSgyLCBpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogWy4uLkwsIC4uLlJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICckJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlVGVybWluYWwodGVtcGxhdGUuc2xpY2UoaSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogW0wsIC4uLlJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGFyc2UodGVtcGxhdGVfZHNsKSB7XG4gICAgICAgIHJldHVybiBbLi4uUGFyc2VMaXRlcmFsKHRlbXBsYXRlX2RzbCldO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIuUGFyc2UgPSBQYXJzZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIgPSBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVPcmRpbmFsOiBVc2VkIGZvciBhdXRvICRpZCBnZW5lcmF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IFR5cGVPcmRpbmFsID0gMDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlQnVpbGRlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFR5cGVCdWlsZGVyIHtcbiAgICAvKiogYFtVdGlsaXR5XWAgQ3JlYXRlcyBhIHNjaGVtYSB3aXRob3V0IGBzdGF0aWNgIGFuZCBgcGFyYW1zYCB0eXBlcyAqL1xuICAgIENyZWF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBPbWl0cyBjb21wb3NpdGluZyBzeW1ib2xzIGZyb20gdGhpcyBzY2hlbWEgKi9cbiAgICBTdHJpY3Qoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNjaGVtYSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBUeXBlQnVpbGRlcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTdGFuZGFyZFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgU3RhbmRhcmRUeXBlQnVpbGRlciBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNb2RpZmllcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBPcHRpb25hbCBwcm9wZXJ0eSAqL1xuICAgIE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdPcHRpb25hbCcsIC4uLlR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9O1xuICAgIH1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBSZWFkb25seU9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgUmVhZG9ubHlPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHsgW2V4cG9ydHMuTW9kaWZpZXJdOiAnUmVhZG9ubHlPcHRpb25hbCcsIC4uLlR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9O1xuICAgIH1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBSZWFkb25seSBvYmplY3Qgb3IgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHsgW2V4cG9ydHMuTW9kaWZpZXJdOiAnUmVhZG9ubHknLCAuLi5zY2hlbWEgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVHlwZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQW55IHR5cGUgKi9cbiAgICBBbnkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQW55JyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIEFycmF5IHR5cGUgKi9cbiAgICBBcnJheShpdGVtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQXJyYXknLCB0eXBlOiAnYXJyYXknLCBpdGVtczogVHlwZUNsb25lLkNsb25lKGl0ZW1zLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEJvb2xlYW4gdHlwZSAqL1xuICAgIEJvb2xlYW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQm9vbGVhbicsIHR5cGU6ICdib29sZWFuJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQ29tcG9zaXRlIG9iamVjdCB0eXBlLiAqL1xuICAgIENvbXBvc2l0ZShvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdCA9IGV4cG9ydHMuVHlwZS5JbnRlcnNlY3Qob2JqZWN0cywge30pO1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5UmVzb2x2ZXIuUmVzb2x2ZUtleXMoaW50ZXJzZWN0LCB7IGluY2x1ZGVQYXR0ZXJuczogZmFsc2UgfSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGV4cG9ydHMuVHlwZS5JbmRleChpbnRlcnNlY3QsIFtrZXldKSB9KSwge30pO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgRW51bSB0eXBlICovXG4gICAgRW51bShpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoaXRlbSkuZmlsdGVyKChrZXkpID0+IGlzTmFOKGtleSkpLm1hcCgoa2V5KSA9PiBpdGVtW2tleV0pO1xuICAgICAgICBjb25zdCBhbnlPZiA9IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHsgW2V4cG9ydHMuS2luZF06ICdMaXRlcmFsJywgdHlwZTogJ3N0cmluZycsIGNvbnN0OiB2YWx1ZSB9IDogeyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnbnVtYmVyJywgY29uc3Q6IHZhbHVlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmlvbicsIGFueU9mIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEEgY29uZGl0aW9uYWwgdHlwZSBleHByZXNzaW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIHRydWUgdHlwZSBpZiB0aGUgbGVmdCB0eXBlIGV4dGVuZHMgdGhlIHJpZ2h0ICovXG4gICAgRXh0ZW5kcyhsZWZ0LCByaWdodCwgdHJ1ZVR5cGUsIGZhbHNlVHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN3aXRjaCAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVW5pb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24oW1R5cGVDbG9uZS5DbG9uZSh0cnVlVHlwZSwgb3B0aW9ucyksIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICBjYXNlIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZSh0cnVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoZmFsc2VUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEV4Y2x1ZGVzIGZyb20gdGhlIGxlZnQgdHlwZSBhbnkgdHlwZSB0aGF0IGlzIG5vdCBhc3NpZ25hYmxlIHRvIHRoZSByaWdodCAqL1xuICAgIEV4Y2x1ZGUobGVmdCwgcmlnaHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeGNsdWRlKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUobGVmdCwgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShyaWdodCksIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihsZWZ0KSkge1xuICAgICAgICAgICAgY29uc3QgbmFycm93ZWQgPSBsZWZ0LmFueU9mLmZpbHRlcigoaW5uZXIpID0+IFR5cGVFeHRlbmRzLkV4dGVuZHMoaW5uZXIsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIChuYXJyb3dlZC5sZW5ndGggPT09IDEgPyBUeXBlQ2xvbmUuQ2xvbmUobmFycm93ZWRbMF0sIG9wdGlvbnMpIDogdGhpcy5VbmlvbihuYXJyb3dlZCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSAhPT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgPyB0aGlzLk5ldmVyKG9wdGlvbnMpIDogVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEV4dHJhY3RzIGZyb20gdGhlIGxlZnQgdHlwZSBhbnkgdHlwZSB0aGF0IGlzIGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXh0cmFjdChsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4dHJhY3QoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IFR5cGVDbG9uZS5DbG9uZShsZWZ0LCBvcHRpb25zKSA6IHRoaXMuTmV2ZXIob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBpbmRleGVkIHByb3BlcnR5IHR5cGVzIGZvciB0aGUgZ2l2ZW4ga2V5cyAqL1xuICAgIEluZGV4KHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KHNjaGVtYSkgJiYgVHlwZUd1YXJkLlROdW1iZXIodW5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLml0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkgJiYgVHlwZUd1YXJkLlROdW1iZXIodW5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgPyBbXSA6IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IGl0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24oY2xvbmVkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBJbmRleGVkQWNjZXNzb3IuUmVzb2x2ZShjbG9uZSwga2V5cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIEludGVnZXIgdHlwZSAqL1xuICAgIEludGVnZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnSW50ZWdlcicsIHR5cGU6ICdpbnRlZ2VyJyB9KTtcbiAgICB9XG4gICAgSW50ZXJzZWN0KGFsbE9mLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGFsbE9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICAgICAgaWYgKGFsbE9mLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoYWxsT2ZbMF0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvYmplY3RzID0gYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRPYmplY3Qoc2NoZW1hKSk7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGFsbE9mLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICBjb25zdCBjbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcykgPyB7IHVuZXZhbHVhdGVkUHJvcGVydGllczogVHlwZUNsb25lLkNsb25lKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMgPT09IGZhbHNlIHx8IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBvYmplY3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnSW50ZXJzZWN0JywgdHlwZTogJ29iamVjdCcsIGFsbE9mOiBjbG9uZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnSW50ZXJzZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBLZXlPZiB0eXBlICovXG4gICAgS2V5T2Yoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpWzBdO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdHJpbmcob3B0aW9ucyk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlcjogVW5hYmxlIHRvIHJlc29sdmUga2V5IHR5cGUgZnJvbSBSZWNvcmQga2V5IHBhdHRlcm4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgPyBbXSA6IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxzID0gaXRlbXMubWFwKChfLCBpbmRleCkgPT4gZXhwb3J0cy5UeXBlLkxpdGVyYWwoaW5kZXgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlVuaW9uKGxpdGVyYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEFycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxzID0ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5MaXRlcmFsKGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIExpdGVyYWwgdHlwZSAqL1xuICAgIExpdGVyYWwodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCBjb25zdDogdmFsdWUsIHR5cGU6IHR5cGVvZiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTmV2ZXIgdHlwZSAqL1xuICAgIE5ldmVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ05ldmVyJywgbm90OiB7fSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTm90IHR5cGUgKi9cbiAgICBOb3Qobm90LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTm90Jywgbm90IH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOdWxsIHR5cGUgKi9cbiAgICBOdWxsKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ051bGwnLCB0eXBlOiAnbnVsbCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bWJlciB0eXBlICovXG4gICAgTnVtYmVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ051bWJlcicsIHR5cGU6ICdudW1iZXInIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gT2JqZWN0IHR5cGUgKi9cbiAgICBPYmplY3QocHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5S2V5cyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsS2V5cyA9IHByb3BlcnR5S2V5cy5maWx0ZXIoKGtleSkgPT4gVHlwZUd1YXJkLlRPcHRpb25hbChwcm9wZXJ0aWVzW2tleV0pIHx8IFR5cGVHdWFyZC5UUmVhZG9ubHlPcHRpb25hbChwcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigobmFtZSkgPT4gIW9wdGlvbmFsS2V5cy5pbmNsdWRlcyhuYW1lKSk7XG4gICAgICAgIGNvbnN0IGNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy5hZGRpdGlvbmFsUHJvcGVydGllcykgPyB7IGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy5hZGRpdGlvbmFsUHJvcGVydGllcywge30pIH0gOiB7fTtcbiAgICAgICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHByb3BlcnR5S2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiAoeyAuLi5hY2MsIFtrZXldOiBUeXBlQ2xvbmUuQ2xvbmUocHJvcGVydGllc1trZXldLCB7fSkgfSksIHt9KTtcbiAgICAgICAgaWYgKHJlcXVpcmVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRBZGRpdGlvbmFsUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdPYmplY3QnLCB0eXBlOiAnb2JqZWN0JywgcHJvcGVydGllczogY2xvbmVkUHJvcGVydGllcywgcmVxdWlyZWQ6IHJlcXVpcmVkS2V5cyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9taXQoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IHNjaGVtYS5yZXF1aXJlZC5maWx0ZXIoKGtleSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHNjaGVtYSk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgT3B0aW9uYWwgKi9cbiAgICBQYXJ0aWFsKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGx5KHNjaGVtYSkge1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBzd2l0Y2ggKHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5T3B0aW9uYWwnOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5JzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5mb3JFYWNoKGtleSA9PiBBcHBseShzY2hlbWEucHJvcGVydGllc1trZXldKSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgUGljayhzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiBrZXlzLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnJlcXVpcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY29yZCB0eXBlICovXG4gICAgUmVjb3JkKGtleSwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdChrZXkucGF0dGVybik7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICA/ICh0aGlzLk9iamVjdChbLi4uVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlKGV4cHJlc3Npb24pXS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoeyAuLi5hY2MsIFtrZXldOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSksIHt9KSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgOiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtrZXkucGF0dGVybl06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdW5pb24gPSBVbmlvblJlc29sdmVyLlJlc29sdmUoa2V5KTtcbiAgICAgICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCh1bmlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdW5pb24uYW55T2YucmVkdWNlKChhY2MsIGxpdGVyYWwpID0+ICh7IC4uLmFjYywgW2xpdGVyYWwuY29uc3RdOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSksIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QocHJvcGVydGllcywgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5IaW50XTogJ1JlY29yZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVCdWlsZGVyOiBSZWNvcmQga2V5IG9mIHR5cGUgdW5pb24gY29udGFpbnMgbm9uLWxpdGVyYWwgdHlwZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVExpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkuY29uc3QgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBrZXkuY29uc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuT2JqZWN0KHsgW2tleS5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSBsaXRlcmFsIGlzIG5vdCBvZiB0eXBlIHN0cmluZyBvciBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoa2V5KSB8fCBUeXBlR3VhcmQuVE51bWJlcihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3Q7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1JlY29yZCcsIHR5cGU6ICdvYmplY3QnLCBwYXR0ZXJuUHJvcGVydGllczogeyBbcGF0dGVybl06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBrZXkucGF0dGVybiA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3QgOiBrZXkucGF0dGVybjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgU3RhbmRhcmRUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBpcyBhbiBpbnZhbGlkIHR5cGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBSZWN1cnNpdmUgdHlwZSAqL1xuICAgIFJlY3Vyc2l2ZShjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLiRpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb3B0aW9ucy4kaWQgPSBgVCR7VHlwZU9yZGluYWwrK31gO1xuICAgICAgICBjb25zdCB0aGlzVHlwZSA9IGNhbGxiYWNrKHsgW2V4cG9ydHMuS2luZF06ICdUaGlzJywgJHJlZjogYCR7b3B0aW9ucy4kaWR9YCB9KTtcbiAgICAgICAgdGhpc1R5cGUuJGlkID0gb3B0aW9ucy4kaWQ7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjdXJzaXZlJywgLi4udGhpc1R5cGUgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlZiB0eXBlLiBUaGUgcmVmZXJlbmNlZCB0eXBlIG11c3QgY29udGFpbiBhICRpZCAqL1xuICAgIFJlZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoc2NoZW1hLiRpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1N0YW5kYXJkVHlwZUJ1aWxkZXIuUmVmOiBUYXJnZXQgdHlwZSBtdXN0IHNwZWNpZnkgYW4gJGlkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVmJywgJHJlZjogc2NoZW1hLiRpZCB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgbWFwcGVkIHR5cGUgd2hlcmUgYWxsIHByb3BlcnRpZXMgYXJlIFJlcXVpcmVkICovXG4gICAgUmVxdWlyZWQoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5JzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnT3B0aW9uYWwnOlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIFJldHVybnMgYSBzY2hlbWEgYXJyYXkgd2hpY2ggYWxsb3dzIHR5cGVzIHRvIGNvbXBvc2Ugd2l0aCB0aGUgSmF2YVNjcmlwdCBzcHJlYWQgb3BlcmF0b3IgKi9cbiAgICBSZXN0KHNjaGVtYSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShzY2hlbWEpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBTdHJpbmcgdHlwZSAqL1xuICAgIFN0cmluZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdTdHJpbmcnLCB0eXBlOiAnc3RyaW5nJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlICovXG4gICAgVGVtcGxhdGVMaXRlcmFsKHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICh0eXBlb2YgdW5yZXNvbHZlZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICA/IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4uQ3JlYXRlKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSh1bnJlc29sdmVkKSlcbiAgICAgICAgICAgIDogVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUodW5yZXNvbHZlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVGVtcGxhdGVMaXRlcmFsJywgdHlwZTogJ3N0cmluZycsIHBhdHRlcm4gfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFR1cGxlIHR5cGUgKi9cbiAgICBUdXBsZShpdGVtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFthZGRpdGlvbmFsSXRlbXMsIG1pbkl0ZW1zLCBtYXhJdGVtc10gPSBbZmFsc2UsIGl0ZW1zLmxlbmd0aCwgaXRlbXMubGVuZ3RoXTtcbiAgICAgICAgY29uc3QgY2xvbmVkSXRlbXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKGl0ZW1zLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgaXRlbXM6IGNsb25lZEl0ZW1zLCBhZGRpdGlvbmFsSXRlbXMsIG1pbkl0ZW1zLCBtYXhJdGVtcyB9IDpcbiAgICAgICAgICAgIHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUdXBsZScsIHR5cGU6ICdhcnJheScsIG1pbkl0ZW1zLCBtYXhJdGVtcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHNjaGVtYSk7XG4gICAgfVxuICAgIFVuaW9uKHVuaW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUodW5pb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYW55T2YgPSB1bmlvbjtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTmV2ZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYW55T2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShUeXBlQ2xvbmUuQ2xvbmUoYW55T2ZbMF0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZEFueU9mID0gYW55T2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2Y6IGNsb25lZEFueU9mIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBVbmtub3duIHR5cGUgKi9cbiAgICBVbmtub3duKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1Vua25vd24nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBVbnNhZmUgdHlwZSB0aGF0IGluZmVycyBmb3IgdGhlIGdlbmVyaWMgYXJndW1lbnQgKi9cbiAgICBVbnNhZmUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiBvcHRpb25zW2V4cG9ydHMuS2luZF0gfHwgJ1Vuc2FmZScgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFuZGFyZFR5cGVCdWlsZGVyID0gU3RhbmRhcmRUeXBlQnVpbGRlcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHRlbmRlZFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgRXh0ZW5kZWRUeXBlQnVpbGRlciBleHRlbmRzIFN0YW5kYXJkVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIEJpZ0ludCB0eXBlICovXG4gICAgQmlnSW50KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0JpZ0ludCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnQmlnSW50JyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgQ29uc3RydWN0b3JQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvclBhcmFtZXRlcnMoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVHVwbGUoWy4uLnNjaGVtYS5wYXJhbWV0ZXJzXSwgeyAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBDb25zdHJ1Y3RvciB0eXBlICovXG4gICAgQ29uc3RydWN0b3IocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQ29uc3RydWN0b3InLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0NvbnN0cnVjdG9yJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgRGF0ZSB0eXBlICovXG4gICAgRGF0ZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdEYXRlJywgdHlwZTogJ29iamVjdCcsIGluc3RhbmNlT2Y6ICdEYXRlJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgRnVuY3Rpb24gdHlwZSAqL1xuICAgIEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHJldHVybnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUmV0dXJucyA9IFR5cGVDbG9uZS5DbG9uZShyZXR1cm5zLCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLm1hcCgocGFyYW1ldGVyKSA9PiBUeXBlQ2xvbmUuQ2xvbmUocGFyYW1ldGVyLCB7fSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0Z1bmN0aW9uJywgdHlwZTogJ29iamVjdCcsIGluc3RhbmNlT2Y6ICdGdW5jdGlvbicsIHBhcmFtZXRlcnM6IGNsb25lZFBhcmFtZXRlcnMsIHJldHVybnM6IGNsb25lZFJldHVybnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIEluc3RhbmNlVHlwZSBmcm9tIHRoZSBnaXZlbiBDb25zdHJ1Y3RvciAqL1xuICAgIEluc3RhbmNlVHlwZShzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHNjaGVtYS5yZXR1cm5zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgUGFyYW1ldGVycyBmcm9tIHRoZSBnaXZlbiBGdW5jdGlvbiB0eXBlICovXG4gICAgUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShzY2hlbWEucGFyYW1ldGVycywgeyAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBQcm9taXNlIHR5cGUgKi9cbiAgICBQcm9taXNlKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1Byb21pc2UnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ1Byb21pc2UnLCBpdGVtOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbSwge30pIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdHlwZSAqL1xuICAgIFJlZ0V4KHJlZ2V4LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdTdHJpbmcnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybjogcmVnZXguc291cmNlIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBSZXR1cm5UeXBlIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uICovXG4gICAgUmV0dXJuVHlwZShzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHNjaGVtYS5yZXR1cm5zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgU3ltYm9sIHR5cGUgKi9cbiAgICBTeW1ib2wob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N5bWJvbCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnU3ltYm9sJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgVW5kZWZpbmVkIHR5cGUgKi9cbiAgICBVbmRlZmluZWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5kZWZpbmVkJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdVbmRlZmluZWQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVaW50OEFycmF5IHR5cGUgKi9cbiAgICBVaW50OEFycmF5KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VpbnQ4QXJyYXknLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ1VpbnQ4QXJyYXknIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBWb2lkIHR5cGUgKi9cbiAgICBWb2lkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1ZvaWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1ZvaWQnIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IEV4dGVuZGVkVHlwZUJ1aWxkZXI7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5TdGFuZGFyZFR5cGUgPSBuZXcgU3RhbmRhcmRUeXBlQnVpbGRlcigpO1xuLyoqIEpTT04gU2NoZW1hIFR5cGVCdWlsZGVyIHdpdGggU3RhdGljIFJlc29sdXRpb24gZm9yIFR5cGVTY3JpcHQgKi9cbmV4cG9ydHMuVHlwZSA9IG5ldyBFeHRlbmRlZFR5cGVCdWlsZGVyKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@sinclair+typebox@0.29.6/node_modules/@sinclair/typebox/typebox.js\n");

/***/ })

};
;